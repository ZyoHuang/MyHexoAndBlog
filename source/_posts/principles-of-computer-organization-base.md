---
title: 计算机组成原理复习纲要
date:
updated:
tags: 计算机科学与技术
categories:
  - - CS基础
    - 计算机组成原理
keywords:
top_img:
cover:
katex: true
aplayer:
---
<meta name="referrer" content="no-referrer" />

<h1>计算机系统概述</h1>

<h2>冯 诺依曼计算机</h2>

<h3>五大功能部件</h3>

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231202753.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231202753.png" alt="" /></a>

<h3>基本要点</h3>

计算机由五大部件组成，采用二进制形式表示数据和指令。
采用存储程序方式。
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231203750.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231203750.png" alt="" /></a>

<h2>输入设备</h2>

将程序和数据以机器所能识别和接受的信息形式输入到计算机内。
比如键盘、鼠标、扫描仪、语音输入设备、手写笔、触摸屏、数码摄像设备等。

<h2>输出设备</h2>

将计算机处理的结果以人们所能接受的信息形式或其它系统所要求的信息形式输出。
如显示器、打印机、绘图仪 、音箱等。

<h2>存储器</h2>

用于存放程序和数据。存储器是计算机存储信息的核心。

<h3>主存储器(主存，内存)</h3>

CPU能直接访问，主存分为若干个存储单元，每个单元都有唯一的地址编码，通常是按<code>字节</code>或<code>字节的整数倍</code>编码。存储器总是<code>按地址访问</code>的，

<h3>辅助存储器(外存，辅存)</h3>

CPU<code>不能直接访问</code>，辅存中的信息必须调入主存后，才能为CPU所使用。
辅存速度较慢，但容量大，用于存放CPU暂时不用的程序和数据。
比如软盘、硬盘、光盘、磁带机等。

<h2>运算器</h2>

用于对数据的加工处理，完成算术逻辑运算。

<h3>组成</h3>

核心是算术逻辑部件(Arithmetic and Logical Unit)，简称为ALU。
还有若干寄存器，用于存放操作数、中间结果或最终结果。

<h2>控制器</h2>

控制器是整个计算机的指挥中心。用于控制整个计算机系统中的各部件有条不紊地进行工作。
计算机控制器是根据事先编好的程序进行指挥的。
程序计数器PC（Program Counter）：存放将要执行的指令的地址（指向存储单元），具有自 增功能。
指令寄存器IR（ Instruction  Register）存放当前正在执行的指令
指令译码器ID（Instruction Decoder）分析指令
时序部件（Sequencer）
控制信号发生器
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231203448.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231203448.png" alt="" /></a>

<h3>工作过程</h3>

事先编制好程序，并连同所需的数据预先存入主存中。运行程序时，由控制器按照存入存储器中的程序自动地、连续地从存储器中依次取出指令并执行，直到获得所要求的结果为止。

<h2>程序设计语言的不同级别</h2>

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231204101.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231204101.png" alt="" /></a>

<h1>信息表示</h1>

<h2>常用进位计数制</h2>

<h3>二进制</h3>

数字0,1
后缀B
1010B

<h3>八进制</h3>

数字0,1,2,3,4,5,6,7
后缀O或Q
137.67Q

<h3>十进制</h3>

数字0，1,2,3,4,5,6,7,8,9
后缀D
1356D

<h3>十六进制</h3>

数字0,1,2,3,4,5,6,7,8,9，A,B,C,D,E,F
后缀H
19EH

<h2>进制转换</h2>

<h3>任意进制转十进制</h3>

按权相加(这里以二进制为例，其他进制同理)
$${(11.101)}<em>2\;=\;1\times2^1+1\times2^0+1\times2^{-1}+0\times2^{-2}+1\times2^{-3}\=2+1+0.5+0.125\={(3.625)}</em>{10}$$

<h3>十进制转换任意进制</h3>

<code>整数部分与小数部分分别处理</code>
整数部分：除基取余
① 把被转换的十进制整数除以基数R，取其余数即为R进制整数的最低位的数字。
② 再用基数R去除前次所得的商，所得余数即为R进制整数相应位的数字。
③ 重复②，直到商为0为止。
小数部分：乘基取整
① 把被转换的十进制小数乘以基数R，取乘积的整数部分作为R进制小数的最高位的数字。
② 再用基数R乘前一步乘积的小数部分，取新的乘积的整数部分为R进制小数相应位的数字。
③ 重复②，直到乘积的小数部分为0或求得所要求的位数为止。
以116.842转二进制(保留6位小数)为例，其他进制同理
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231212613.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231212613.png" alt="" /></a>
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231212735.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/12/QQ截图20191231212735.png" alt="" /></a>

<h3>二，八，十六进制之间的互转</h3>

<h4>二进制<->八进制：</h4>

<code>二进制数→八进制数</code>
      整数部分：从最低有效位开始，每三位二进制数对应一
                          位八 进制数，不足三位高位补“0”。
      小数部分：从最高有效位开始，每三位二进制数对应一
                          位八进制数，不足三位，低位补“0”。
<code>八进制数→二进制数</code>
      将被转换的八进制数的每一位用三位二进制表示。

<h4>二进制<->十六进制</h4>

<code>二进制数→十六进制数</code>
      整数部分：从最低有效位开始，每四位二进制数对应一
                          位十六进制数，不足四位高位补“0”。
      小数部分：从最高有效位开始，每四位二进制数对应一
                          位十六进制数，不足四位，低位补“0”。
<code>十六进制数→二进制数</code>
      将被转换的十六进制数的每一位用四位二进制表示。

<h4>八进制<->十六进制</h4>

<code>八进制<->二进制<->十六进制</code>

<h2>机器数的表示</h2>

<h3>机器数与真值</h3>

<h4>机器数</h4>

计算机中的数据
符号和数值均二进制代码化。
小数点隐含在某一固定位置上，不占存储空间。
位数受机器字长的限制。超过机器字长的数值位要舍去。
机器数可分为：
      无符号数：机器字长的所有二进制位均表示数值
      带符号数：第1个二进制位为符号位，其余为数值部分

<h4>真值</h4>

用±|A|表示的实际数值。
例：8位机器数为：11011011
若为无符号整数，其真值为 219
若为带符号整数，且采用原码表示，则最高位为符号， 1 1011011 表示二进制整数 -1011011，其真值为 -91

<h3>原码</h3>

<h4>真值，机器数，原码互转</h4>

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101131709.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101131709.png" alt="" /></a>

<h4>0的表示</h4>

纯小数：<code>[+0]原</code>=0.00...0，<code>[-0]原</code>=1.00...0
纯整数：<code>[+0]原</code>=00...0，<code>[-0]原</code>=10...0

<h4>移位规则</h4>

<code>符号位不变，数值部分左移或右移，移出的空位填0。</code>
原码左移时若将有效位移出（x1=1），则出错。
<code>例如：[x]原 = 1110，左移一位变成[2x]原 = 1100，就出错了</code>

<h4>优缺点</h4>

优点：
      1) 简单；
      2) 与真值的转换容易。
缺点：
      1) 0有两种表示，给使用带来不便；
      2) 原码表示的加减运算复杂。

<h3>补码</h3>

<code>模</code>：是指一个计量系统的量程。如时钟的模为12，记作mod 12。在计算机中，超过字长的被丢失的量就是模。 例如，一个m位的寄存器，若存放的是纯小数，则模为2，若存放的是纯整数，则模为$2^m$。

<h4>真值，补码，原码互转</h4>

若x≥0 ，则[x]补＝[x]原=x，且置x0为0;
若x<0，x与[x]补互转：<code>则置x0为1，将x的数值位按位取反，末位加1</code>，即得到[x]补。
若[x]补与[x]原互转：符号位1不变，数值为按位取反，末尾加一
例：当x＝＋0.1011， [x]补＝0.1011
当x＝－0.1011，[x]补＝1.0101
当x＝＋1011， [x]补＝01011
当x＝－1011，[x]补＝10101

<h4>0的表示</h4>

纯小数：[+0]补 = [-0]补=0.00...0
纯整数：[+0]补 = [-0]补=00...0

<h4>-1和$-2^n$的补码表示</h4>

分别为1.00...0和100...0

<h4>有[x]补和[-x]补的关系</h4>

记[x]补称为机器正数， [-x]补称为机器负数。求<code>[-x]补</code>，也称为对[x]补的求补或变补。
记[x]补<code><-></code>[-x]补：找低位第一个1，该1和其后面的0不变，其他位取反。

<h4>补码的移位关系</h4>

右移：符号位不变，数值位右移，空位补与符号位相同的代码。[x]补右移1位得到[x/2]补
左移：符号位不变，数值位左移，空位补0，[x]补左移1位，得到[2x]补
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101140553.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101140553.png" alt="" /></a>

<h3>反码</h3>

反码实质上是补码的一个特例，区别在于反码的模比补
码的模小一个最低位上的 1。
若x≥0 ，则[x]反＝x，且置符号位x0为0。
若x＜0，则置x0为1，将x的数值位按位取反，即得到[x]反。
<img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101141156.png" alt="" />

<h3>移码</h3>

移码表示把真值x在数轴上正向平移1(纯小数)或2n(纯整数)，所以移码也称为增码、余码。
若[x]移和[x]补互转：符号位取反，数值位不变

<h3>四种机器数表示</h3>

(1)  最高位都表示符号位。原码、反码和补码的符号位均是0表示+，1表示-，移码相反。
(2) 移码、补码和反码的符号位可和数值位一起参加运算；原码的符号位必须分开进行处理。
(3) 对于正数，除移码外，其他码值都等于真值本身，而对于负数各有不同的表示。
(4) 对于真值0，原码和反码各有两种不同的表示形式，而补码和移码只有唯一的一种表示形式。
(5) 原码、反码表示的范围是一样的；补码、移码表示的范围是一样的，且比前二者能多表示一个最负的数：$-2^n$（纯整数）或-1（纯小数）。
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101141539.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101141539.png" alt="" /></a>

<h2>数据校验码</h2>

数据校验码：具有检测某些错误或带有自动纠正错误能力的数据编码方式。

<h3>奇偶校验码</h3>

在n位的有效信息位AnAn-1…A1上，加1位校验位P，构成n+1位的奇偶校验码AnAn-1…A1P或PAnAn-1…A1。若P使n+1位的校验码中“1”的个数为偶数（奇数），则称为偶校验（奇校验），校验位P又记作Peven（Podd）。
例：求7位信息码1100111的奇校验码和偶校验码（设校验位在最低位）。
解:(1)偶校验码
       Peven ＝1⊕1⊕0⊕0⊕1⊕1⊕1＝1
    ∴偶校验码为11001111。
     (2)奇校验码
      Podd ＝1⊕1⊕0⊕0⊕1⊕1⊕1＝0（上面有一横，意为取反）
    ∴奇校验码为11001110。
<code>若接收到的奇校验码中“1”的个数为偶数，或接收到的偶校验码中“1”的个数为奇数，则表示有一位出错。</code>
例：仍以前面的七位有效信息的奇偶校验码为例，若发送方发送的奇校验码为11001110，经网络传送后，若接收方收到的奇校验码为：
11011110
        Eodd= 1⊕1⊕0⊕1⊕1⊕1⊕1 ⊕0 = 1，认为有错。
10101111
        Eodd =1，认为有错。
11100110
        Eodd =0，认为无错！
<code>只能发现奇数位个错误，而无法发现偶数位个错误，并且无法自动纠正错误。</code>

<h3>海明校验码</h3>

在奇偶校验的基础上，设置多个校验位，构成多组奇偶校验，使每一个信息位被两个或两个以上校验位校验，从而不仅可以发现错误，而且还能确定出错位置，进而能自动纠正错误。
海明校验码的编码步骤
(1)  n位有效信息选择k个校验位，构成n+k位的海明校验码。若校验码位号从左向右（或从右向左）按从1到n+k排列，则校验位的位号分别为$2^i$(i＝0，1，2…k-1)，校验位记作P$2^i$，有效信息位按原顺序安排在其余位置上。
(2)  k个校验位构成k组奇偶校验，每个有效信息位都被两个或两个以上的校验位校验，规则：被校验的有效信息位的位号等于校验它的校验位位号之和。
(3) 统计参与各组奇偶校验的位号，按奇偶校验原理，由已知的有效信息位求出各校验位，进而形成海明校验码。
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101151201.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101151201.png" alt="" /></a>
海明校验码的校验方法
对K组奇偶校验码分别进行校验，校验结果形成K位的“指误字” EkEk-1…E2E1。
     若EkEk-1…E2E1 ＝全0，则表示无错；
     若EkEk-1…E2E1 ≠全0，则表示有错，并且指误字代码所对应的十进制值就是出错位的位号。将该位取反，错误码即得到自动纠正。
例：上例中字符‘ K’的海明校验码为10110010011(采用偶校验)，若接收方接收到的海明码为：
10110010011
      E1even＝P1⊕A7⊕A6⊕A4⊕A3⊕A1=1⊕1⊕0⊕1⊕0⊕1=0
      E2even＝P2⊕A7⊕A5⊕A4⊕A2⊕A1=0⊕1⊕0⊕1⊕1⊕1=0
      E3even＝P4⊕A6⊕A5⊕A4 =1⊕0⊕0⊕1=0
      E4even＝P8⊕A3⊕A2⊕A1=0⊕0⊕1⊕1=0
 ∴指误字E4E3E2E1 ＝0000，无错！
10111010011
      E1even＝P1⊕A7⊕A6⊕A4⊕A3⊕A1=1⊕1⊕1⊕1⊕0⊕1=1
      E2even＝P2⊕A7⊕A5⊕A4⊕A2⊕A1=0⊕1⊕0⊕1⊕1⊕1=0
      E3even＝P4⊕A6⊕A5⊕A4 =1⊕1⊕0⊕1=1
      E4even＝P8⊕A3⊕A2⊕A1=0⊕0⊕1⊕1=0
∴指误字E4E3E2E1 ＝0101B=5，认为位号为5的那位出错，
并将其自动取反，得到10110010011。可见能正确纠
错！
10111110011
      E1even＝P1⊕A7⊕A6⊕A4⊕A3⊕A1=1⊕1⊕1⊕1⊕0⊕1=1
      E2even＝P2⊕A7⊕A5⊕A4⊕A2⊕A1=0⊕1⊕1⊕1⊕1⊕1=1
      E3even＝P4⊕A6⊕A5⊕A4 =1⊕1⊕1⊕1=0
      E4even＝P8⊕A3⊕A2⊕A1=0⊕0⊕1⊕1=0
∴指误字E4E3E2E1＝0011B=3，认为位号为3的那位出
错，并将其自动取反，得到10011110011。可见越纠越错！
<code>仅在只有一个错误时，才能检1纠1错，否则越纠越错。</code>

<h2>机器数的定点表示和浮点表示</h2>

任何一个数都可以表示为${(N)}_R=M\times R^e$

M：尾数。代表数N的<code>有效数字</code>。计算机中一般表示为<code>纯小数</code>。
R：尾数基值。计算机中常用的R可取2、8、16等。
e：阶码。代表数N的<code>小数点的实际位置</code>。一般表示为纯整数。
根据<code>小数点的位置是否固定</code>，计算机中的数据格式又分为两种：<code>定点表示</code>和<code>浮点表示</code>。

<h3>定点表示</h3>

定点表示：约定计算机中所有数据的小数点位置是固定不变的，即阶码e的取值固定不变。
定点数：采用定点表示的数据。

<h3>定点数格式</h3>

定点数有两种表示方法：定点小数和定点整数。
机器确定后，e就确定了，不能更改，也不能两者并存。

<h3>溢出概念</h3>

若运算结果超出机器所能表示的数据范围，称为溢出。

<h3>定点数缺点</h3>

比例因子难以选择，容易产生溢出或影响精度
表示的数据范围小
存储单元的利用率低

<h3>浮点表示</h3>

浮点表示：指小数点位置可变的数据表示形式。即 e 值是可变的。

<h3>浮点数的格式</h3>

$${(N)}_R=M\times R^e$$

基数R用隐含方法表示。通常取R＝2。
阶码e表示数的小数点实际位置，可用<code>补码</code>或<code>移码</code>表示。
尾数M表示数的<code>有效数字</code>，可用<code>补码</code>或<code>原码</code>表示。
典型的浮点数格式由阶码e和尾数M组成。

<h3>浮点数的规格化表示</h3>

规格化的目的：为了浮点数表示的唯一性。为了充分利用尾数的位数，以保留更多的有效数字，从而提高运算精度 。
浮点数的规格化表示是指尾数的规格化表示。

<h4>规格化数的定义</h4>

1.尾数采用原码表示，规格化标志，S1=1，如0.1xxx,1.1xxxx
2.尾数采用补码表示，规格化标志，Sf⊕S1=1(Sf!=S1)，如0.1xxx,1.0xxx

<h3>浮点数的表示范围</h3>

阶码用移码，尾数用补码
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101161453.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101161453.png" alt="" /></a>

<h3>IEEE754浮点数标准</h3>

每个浮点数由三部分组成，数符S，指数E，尾数M
 浮点数可采用以下四种基本格式：
 (1)单精度格式(32位)：E＝8位，M＝23位。
 (2)扩展单精度格式：E≥11位，M＝31位。
 (3)双精度格式(64位)：E＝11位，M＝52位。
 (4)扩展双精度格式：E≥15位，M≥63位。

<h3>定点原码加减运算及实现</h3>

（1）符号位<code>不能</code>和数据一起参加运算；
（2）符号位和加减法指令共同作为运算的依据。
运算的规则：
（1） 加法：同号求和，异号求差；
      减法：异号求和，同号求差。
（2） 求和时，两操作数的数值位相加得到和的数值位；
           数值最高位产生进位，则结果<code>溢出</code>；
           和的符号位采用第一操作数(被加数/被减数)的符号。
（3） 求差时，第一操作数的数值位加上第二操作数（加数/减数）的数值位的补码。 分两种情况讨论：
        ① 最高数值位有进位，表明加法结果为正，所得数值位正确，结果的符号位采用第一操作数的符号。
    ②最高数值位无进位，表明加法结果为负（补码形式），应对其求补，还原为绝对值形式的数值位，结果的符号位为第一操作数的符号变反。
例：已知[X]原＝0.1101，[Y]原＝1.1001，  求[X±Y]原。
解：
[X+Y]原：对两数求差，
        .1101－ .1001=.1101+.0111=1.0100
        [X+Y]原＝0.0100
[X－Y]原：两数求和，
      .1101+.1001=1.0110

<h3>定点补码加减运算及实现</h3>

补码加减运算的基本规则
① 参加运算的各个操作数均以补码表示，运算结果仍以补码表示。
② 符号位与数值位<code>一起参加运算</code>。
③ 若求和，则将两补码数直接相加，得到两数之和的补码；若求差，则将减数变补(由[y]补求[－y]补)，然后与被减数相加，得到两数之差的补码。
④ 补码总是对确定的模而言，若运算结果超过模(有从符号位上产生的进位)，则将模自动丢掉。

例2：x=+1001，y=+0110，求x± y。
解：∵ [x]补=01001, [y]补=00110
        ∴[x+y]补= [x]补+ [y]补= 01001+00110=01111
        ∴ x+y=+1111
        ∵[-y]补=11010
        ∴[x-y]补= [x]补+ [-y]补= 01001+11010= 00011
        ∴ x-y=+0011

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101195031.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101195031.png" alt="" /></a>

<h3>溢出判别与变形补码</h3>

采用变形补码运算
变形补码的实质是双符号位补码。
即[x]变形补＝x0x0.x1x2…xn ，[y]变形补＝y0y0.y1y2…yn
设[s]变形补＝ [x]变形补+[y]变形补= sf1sf2.s1s2…sn
当sf1≠sf2时，出现溢出。其中：
      sf1sf2＝01      表示正溢出
      sf1sf2＝10      表示负溢出
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101200445.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101200445.png" alt="" /></a>

<h3>定点数移位运算</h3>

是计算机中基本运算之一，和加减运算相结合可实现乘除运算。包括逻辑移位、算术移位和循环移位。
一、逻辑移位
数据为无符号数或纯逻辑代码，移位时不考虑符号。
逻辑左移：将寄存器的每一位数据向左移动一个位置，最低位补0，最高位移至进位位；
逻辑右移：将寄存器的每一位数据向右移动一个位置，最低位移至进位位，最高位补0。
二，逻辑移位
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101202543.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101202543.png" alt="" /></a>

<h3>定点补码一位乘法运算</h3>

补码一位乘法的算法规则
参加运算的数均以补码表示，结果仍以补码表示。
增设yn+1，且初始化为0，部分积初始化为0。
<code>部分积</code>与<code>被乘数</code>采用<code>双符号位</code>，且符号位参加运算。
判别ynyn+1，并采取相应的操作。其中，右移指将部分积连同乘数（ 包括yn+1 ）一起算术右移。
重复④，共做<code>n+1</code>次操作，<code>最后一次不移位！</code>
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101203928.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101203928.png" alt="" /></a>

<h1>存储器和存储体系</h1>

<h2>存储器概述</h2>

一：按与CPU的连接和功能分类
主存储器（主存、内存）：CPU能够直接访问的存储器。
辅助存储器（辅存、外存）：CPU不能直接访问的存储器。
高速缓冲存储器（Cache）：是一种介于主存与CPU之间用于解决CPU与主存间速度匹配问题的高速小容量的存储器。Cache用于存放CPU立即要运行或刚使用过的程序和数据。
二：按存取方式分类
随机存取存储器(RAM, Random Access Memory)
存储器任何单元的内容均可按其地址随机地读取或写入，且存取时间与单元的物理位置无关。RAM主要用于组成主存。
<code>只读存储器(ROM, Read Only Memory)</code>
存储器的内容只能随机地读出而不能随便写入和修改。ROM可作为主存的一部分，用于存放不变的程序和数据。ROM还可用作其它固定存储器，如存放微程序的控制存储器、存放字符点阵图案的字符发生器等。
顺序存取存储器(SAM, Sequential Access Memory)
存储器所存信息的排列、寻址和读写操作均是按顺序进行的，没有唯一对应的地址，并且存取时间与信息在存储器中的物理位置有关。如磁带存储器。
直接存取存储器(DAM, Direct Access Memory)
介于RAM和SAM之间的存储器。也称半顺序存储器。典型的DAM如磁盘，当进行信息存取时，先进行寻道，属于随机方式，然后在磁道中寻找扇区，属于顺序方式。

<h2>主存的组成与操作</h2>

<h3>存储元</h3>

能够存储一位二进制信息的物理器件。存储元是存储器
中最小的存储单位。作为存储元的条件：
① 有两个稳定状态，对应二进制的“0”、“1” 。
② 在外界的激励下，可写入“0”、“1”。
③ 能够识别器件当前的状态。即可读出所存的“0”、“1”。

<h3>存储单元</h3>

由一组存储元件组成，可以同时进行读写。

<h3>存储体</h3>

把大量存储单元电路按一定形式排列起来，即构成存储体。存储体一般排列成阵列形式，所以又称存储阵列

<h3>存储单元的地址</h3>

存储体中每个存储单元被赋予的一个唯一的编号，该编号就是存储单元的地址。当访问某存储单元时，必须首先给出该存储单元的地址。

<h3>存储单元的编址</h3>

① 按字节编址：相邻的两个单元是两个字节。
② 按字编址：相邻的两个单元是两个字。

<h3>主存读写过程</h3>

CPU通过地址总线把地址码送到主存地址寄存器MAR； CPU通过数据总线向主存数据寄存器MDR发送写入数据或从主存的MDR接收读出数据；
CPU通过控制总线把地址码向主存发送读、写控制信号；

<h3>存储器的主要性能指标</h3>

存储容量：存储器所能存储的二进制信息总量

<h4>存储容量表示</h4>

①在以字节为编址单位的机器中，常用<code>字节</code>表示存储容量。
例如：4MB表示主存可容纳4兆个字节信息。
②对于存储器芯片，用<code>存储单元数×每个单元的位数</code>表示。
例如：512k×16位，表示主存有512k个单元，每个单元为16位。

<h4>存储容量的主要计量单位</h4>

1K=$2^{10}$=1024
1M=$2^{20}$=$2^{10}$K=1048576
1G=$2^{30}$=$2^{10}$M=1073741824

<h4>容量与存储器地址线的关系</h4>

1K=$2^{10}$需要10根地址线
1M=$2^{20}$需要20根地址线
256M=$2^{28}$需要28根地址线

<h2>半导体随机存储存储器</h2>

主要分RAM和ROM两大类，比较重要的是RAM中的MOS型存储器类别
SRAM：静态随机存取存储器
Static
集成度较低（六管），单片容量较小
不需要刷新
速度快，曾在Pentium主板上用作二级高速缓存
通常是字选方式
DRAM：动态随机存取存储器
Dynamic
集成度高（单管），单片容量较大
需要定时刷新
速度较低，多用作主存储器
通常是位选方式

<h2>主存储器的组织</h2>

<h3>主存储器容量的扩充</h3>

由于一块存储器芯片的容量总是有限的，因此一个存储器总是由一定数量的存储器芯片构成。
$$\mathrm{芯片总片数}=\frac{\mathrm{存储器总单元数}\times\mathrm{位数}}{\mathrm{每篇芯片单元数}\times\mathrm{位数}}$$

<h2>高速缓冲存储器</h2>

避免 CPU “空等” 现象
CPU 和主存（DRAM）的速度差异
<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101212511.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101212511.png" alt="" /></a>
基于程序访问的局部性原理

<h3>地址映像——直接映射</h3>

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101212904.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101212904.png" alt="" /></a>

<h3>命中，不命中，命中率</h3>

Cache命中(hit)：CPU欲访问的数据已在Cache中。
Cache不命中(miss)：CPU欲访问的数据不在Cache内。
命中率：CPU 欲访问的信息在 Cache 中的比率。

<h3>Cache读写操作</h3>

<h4>读操作</h4>

<a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101213137.png"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200101213137.png" alt="" /></a>

<h4>写操作</h4>

如果Cache命中，会遇到如何保持Cache与主存中的内容一致的问题。
      ⑴ 写直达法：即同时写入主存和高速存储器。
写操作时间就是访问主存的时间，读操作时不涉及对主存的写操作，更新策略较容易实现。
      ⑵ 写回法：只写入高速存储器并标记该组修改过。
写操作时间就是访问 Cache 的时间，读操作 Cache 失效发生数据替换时，被替换的块需写回主存，增加了 Cache 的复杂性。
如果Cache不命中
按写分配法：写入主存，同时装入该块到Cache
不按写分配法：直接写入主存，不装入该块到Cache中

<h3>Cache性能分析</h3>

<h4>命中率</h4>

设$N_c$为访问Cache的总命中次数，$N_m$为访问主存的总次数，则 Cache 命中率为 ：
$$h\;=\;\frac{N_c}{N_c+N_m}$$

<h4>平均访问时间</h4>

设 $t_c$ 为命中时的Cache访问时间，$t_m$ 为未命中时的主存访问时间，则Cache – 主存系统的 平均访问时间 为 ：
$$t_a=ht_c+(1-h)t_m$$
平均访问时间 ta 与 命中率 有关

<h4>访问效率</h4>

访问效率 e 与 命中率 有关
$$e=\frac{\mathrm{访问}Cache\mathrm{的时间}}{\mathrm{平均访问时间}}\times100\%$$
设 Cache 命中率 为 h，访问 Cache 的时间为 $t_c$ ，访问 主存 的时间为 $t_m$
$$e=\frac{t_c}{h\times t_c+(1-h)\times t_m}\times100\%$$

<h2>虚拟存储器</h2>

在主存与辅存之间，增加必要的硬件支持，经过操作系统的存储管理软件的管理，使主、辅存之间的信息交换，程序的再定位，地址的转换都能自动进行，使两者形成一个有机的整体。从而得到一个足够大的主存空间
由于程序员可以用到的空间远远大于主存的实际空间，但实际上不存在这么大的主存，故称“虚拟存储器” 。
是以软件为主的技术。
对于多任务或多用户系统，有足够的主存空间。
程序员编程时不必考虑机器实际配备的主存大小.

<h1>指令系统</h1>

指令（机器指令）：控制计算机执行某种操作的命令。
指令字（指令码）：表示一条指令的一串二进制代码。
机器语言：用机器指令设计的编程语言，是计算机硬件实体直接表示控制信息的语言。
机器语言程序：用机器语言编制的程序。任何用其它语言编制的程序，都必须经过 “翻译”，翻译为机器语言程序，才能在机器中正确的运行。
指令系统（指令集）：一台计算机所能执行的全部指令的集合。

<h2>特征</h2>

完备性：指令功能齐全、足够使用
高效性：所编写的程序占据存储空间小、执行速度快
规整性：对称性：所有的寄存器和存储单元都可同等对待，所有的指令都可使用各种寻址方式，匀齐性：可以支持各种数据类型，指令的格式和数据格式的一致性
兼容性：系列机各种机型具有相同的基本结构和共同的基本指令集

<h2>指令的格式</h2>

操作码：指定指令所要完成的操作；
操作数的来源；
结果去向；
下一条指令的地址。
因此，一条指令的基本格式为：
操作码+地址码

<h1>控制器与中央处理器</h1>

控制器是计算机的指挥和控制中心，其主要功能就是根据事先编好并存放在存储器中的解题程序,按所执行指令的具体要求，适时地产生并发出各种控制命令，控制计算机各部件自动、连续、协调地进行工作，直到完成程序的全部功能为止。所以控制器的基本功能就是运行程序。

<h2>控制器的工作过程</h2>

1.取指令：
根据PC提供的指令地址，从存储器中取出所要执行的指令放入IR(指令寄存器)。
2.分析指令：对取出的指令进行译码分析
对指令的操作码进行译码分析。确定指令应完成的操作，产生相应操作的控制电位，去参与形成该指令功能所需要的全部控制命令（微操作控制信号）。
根据寻址方式，形成操作数的有效地址，并按此地址取出操作数据（运算型指令）或形成转移地址(转移类指令)，以实现程序转移。
3.执行指令：
根据指令功能，执行指令所规定的操作，并根据需要，保存操作结果。
一条指令执行结束，若没有异常情况和特殊请求，则按程序顺序，再去取出并执行下一条指令。

<h1>输入输出系统</h1>

输入设备：将外部可读数据转换成计算机内部的数字编码的设备
输出设备：将计算机内部的数字编码转换成外部可读的字符、图形或声音的设备。

<h1>系统总线</h1>

1.总线的基本概念
一组可为多个功能部件共享的公共信息传送线路。
2.总线上信息传输的特点
某一时刻只允许一个部件向总线发送信息，而多个部件可同时从总线商接收信息。
